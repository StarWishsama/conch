// This file is automatically @generated by JceGenerator.
// It is not intended for manual editing.

use bytes::{Bytes, BytesMut};
use tracing::{instrument, trace};

use jce::{JceReader, JceWriter};
use jce::field::{JBool, JByte, JceFieldErr, JceStruct, JDouble, JFloat, JInt, JList, JLong, JMap, JShort, JSList, JString};

////////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Default)]
pub struct HttpServerListReq {
    pub uin: JLong,
    pub timeout: JLong,
    pub c: JByte,
    pub imsi: JString,
    pub is_wifi_conn: JInt,
    pub app_id: JLong,
    pub imei: JString,
    pub h: Option<JLong>,
    pub i: Option<JLong>,
    pub j: Option<JLong>,
    pub k: Option<JByte>,
    pub l: Option<JByte>,
    pub m: Option<JLong>,
    pub n: Option<JBool>,
}

impl JceStruct for HttpServerListReq {
	#[instrument(fields(str = "HTTP 服务器列表请求结构体"), skip(self, b))]
    fn s_to_bytes(&self, b: &mut BytesMut) {
        let mut w = JceWriter::new(b, 1);
        w.put(&self.uin);
        w.put(&self.timeout);
        w.put(&self.c);
        w.put(&self.imsi);
        w.put(&self.is_wifi_conn);
        w.put(&self.app_id);
        w.put(&self.imei);
        match &self.h {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.i {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.j {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.k {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.l {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.m {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.n {
            Some(v) => w.put(v),
            None => {}
        }
        trace!(dsc = "编码完成");
    }

	#[instrument(fields(str = "HTTP 服务器列表请求结构体"), skip(self, b))]
    fn s_from_bytes(&mut self, b: &mut Bytes) -> Result<(), JceFieldErr> {
        let mut r = JceReader::with_tag(b, 1);
        self.uin = r.get()?;
        self.timeout = r.get()?;
        self.c = r.get()?;
        self.imsi = r.get()?;
        self.is_wifi_conn = r.get()?;
        self.app_id = r.get()?;
        self.imei = r.get()?;
        self.h = r.get_optional()?;
        self.i = r.get_optional()?;
        self.j = r.get_optional()?;
        self.k = r.get_optional()?;
        self.l = r.get_optional()?;
        self.m = r.get_optional()?;
        self.n = r.get_optional()?;
        trace!(dsc = "解码完成");
        Ok(())
    }
}

////////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Default)]
pub struct HttpServerListRes {
    pub a: JInt,
    pub socket_mobile_ipv4: JList<HttpServerListResServer>,
    pub socket_wifi_ipv4: JList<HttpServerListResServer>,
    pub d: JInt,
    pub e: JInt,
    pub f: Option<JByte>,
    pub g: Option<JByte>,
    pub h: Option<JInt>,
    pub i: Option<JInt>,
    pub j: Option<JLong>,
    pub k: Option<JInt>,
    pub http_mobile_ipv4: Option<JList<HttpServerListResServer>>,
    pub http_wifi_ipv4: Option<JList<HttpServerListResServer>>,
    pub speedtest_info: Option<JSList>,
    pub socket_ipv6: Option<JList<HttpServerListResServer>>,
    pub http_ipv6: Option<JList<HttpServerListResServer>>,
    pub quic_ipv6: Option<JList<HttpServerListResServer>>,
    pub net_type: Option<JByte>,
    pub he_threshold: Option<JInt>,
    pub policy_id: Option<JString>,
    pub u: Option<JByte>,
}

impl JceStruct for HttpServerListRes {
	#[instrument(fields(str = "HTTP 服务器列表响应结构体"), skip(self, b))]
    fn s_to_bytes(&self, b: &mut BytesMut) {
        let mut w = JceWriter::new(b, 1);
        w.put(&self.a);
        w.put(&self.socket_mobile_ipv4);
        w.put(&self.socket_wifi_ipv4);
        w.put(&self.d);
        w.put(&self.e);
        match &self.f {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.g {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.h {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.i {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.j {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.k {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.http_mobile_ipv4 {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.http_wifi_ipv4 {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.speedtest_info {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.socket_ipv6 {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.http_ipv6 {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.quic_ipv6 {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.net_type {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.he_threshold {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.policy_id {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.u {
            Some(v) => w.put(v),
            None => {}
        }
        trace!(dsc = "编码完成");
    }

	#[instrument(fields(str = "HTTP 服务器列表响应结构体"), skip(self, b))]
    fn s_from_bytes(&mut self, b: &mut Bytes) -> Result<(), JceFieldErr> {
        let mut r = JceReader::with_tag(b, 1);
        self.a = r.get()?;
        self.socket_mobile_ipv4 = r.get()?;
        self.socket_wifi_ipv4 = r.get()?;
        self.d = r.get()?;
        self.e = r.get()?;
        self.f = r.get_optional()?;
        self.g = r.get_optional()?;
        self.h = r.get_optional()?;
        self.i = r.get_optional()?;
        self.j = r.get_optional()?;
        self.k = r.get_optional()?;
        self.http_mobile_ipv4 = r.get_optional()?;
        self.http_wifi_ipv4 = r.get_optional()?;
        self.speedtest_info = r.get_optional()?;
        self.socket_ipv6 = r.get_optional()?;
        self.http_ipv6 = r.get_optional()?;
        self.quic_ipv6 = r.get_optional()?;
        self.net_type = r.get_optional()?;
        self.he_threshold = r.get_optional()?;
        self.policy_id = r.get_optional()?;
        self.u = r.get_optional()?;
        trace!(dsc = "解码完成");
        Ok(())
    }
}

////////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Default)]
pub struct HttpServerListResServer {
    pub ip: JString,
    pub port: JInt,
    pub c: JByte,
    pub d: JByte,
    pub e: Option<JByte>,
    pub f: Option<JInt>,
    pub g: Option<JByte>,
    pub region: Option<JString>,
    pub oper: Option<JString>,
    pub ability: Option<JLong>,
}

impl JceStruct for HttpServerListResServer {
	#[instrument(fields(str = "HTTP 服务器列表响应服务器结构体"), skip(self, b))]
    fn s_to_bytes(&self, b: &mut BytesMut) {
        let mut w = JceWriter::new(b, 1);
        w.put(&self.ip);
        w.put(&self.port);
        w.put(&self.c);
        w.put(&self.d);
        match &self.e {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.f {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.g {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.region {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.oper {
            Some(v) => w.put(v),
            None => {}
        }
        match &self.ability {
            Some(v) => w.put(v),
            None => {}
        }
    }

	#[instrument(fields(str = "HTTP 服务器列表响应服务器结构体"), skip(self, b))]
    fn s_from_bytes(&mut self, b: &mut Bytes) -> Result<(), JceFieldErr> {
        let mut r = JceReader::with_tag(b, 1);
        self.ip = r.get()?;
        self.port = r.get()?;
        self.c = r.get()?;
        self.d = r.get()?;
        self.e = r.get_optional()?;
        self.f = r.get_optional()?;
        self.g = r.get_optional()?;
        self.region = r.get_optional()?;
        self.oper = r.get_optional()?;
        self.ability = r.get_optional()?;
        Ok(())
    }
}

////////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Default)]
pub struct RequestPacket {
    pub version: JShort,
    pub packet_type: JByte,
    pub message_type: JInt,
    pub request_id: JInt,
    pub servant_name: JString,
    pub func_name: JString,
    pub buffer: JSList,
    pub timeout: JInt,
    pub context: JMap<JString, JString>,
    pub status: JMap<JString, JString>,
}

impl JceStruct for RequestPacket {
	#[instrument(fields(str = "Jce 请求数据包"), skip(self, b))]
    fn s_to_bytes(&self, b: &mut BytesMut) {
        let mut w = JceWriter::new(b, 1);
        w.put(&self.version);
        w.put(&self.packet_type);
        w.put(&self.message_type);
        w.put(&self.request_id);
        w.put(&self.servant_name);
        w.put(&self.func_name);
        w.put(&self.buffer);
        w.put(&self.timeout);
        w.put(&self.context);
        w.put(&self.status);
        trace!(dsc = "编码完成");
    }

	#[instrument(fields(str = "Jce 请求数据包"), skip(self, b))]
    fn s_from_bytes(&mut self, b: &mut Bytes) -> Result<(), JceFieldErr> {
        let mut r = JceReader::with_tag(b, 1);
        self.version = r.get()?;
        self.packet_type = r.get()?;
        self.message_type = r.get()?;
        self.request_id = r.get()?;
        self.servant_name = r.get()?;
        self.func_name = r.get()?;
        self.buffer = r.get()?;
        self.timeout = r.get()?;
        self.context = r.get()?;
        self.status = r.get()?;
        trace!(dsc = "解码完成");
        Ok(())
    }
}